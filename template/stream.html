<div id="containerStream"></div>


<div id="sender">
    <img id="author-image" src="">
    <span id="author-name"></span>
</div>

<style>

    @keyframes shake {
        0% {
            transform: translate(0.5px, 0.5px) rotate(0deg) scale(1.01);
        }
        10% {
            transform: translate(-0.5px, -1px) rotate(-0.5deg) scale(1.02);
        }
        20% {
            transform: translate(-1.5px, 0px) rotate(0.5deg) scale(1.03);
        }
        30% {
            transform: translate(1.5px, 1px) rotate(0deg) scale(1.02);
        }
        40% {
            transform: translate(0.5px, -0.5px) rotate(0.5deg) scale(1.01);
        }
        50% {
            transform: translate(-0.5px, 1px) rotate(-0.5deg) scale(1);
        }
        60% {
            transform: translate(-1.5px, 0.5px) rotate(0deg);
        }
        70% {
            transform: translate(1.5px, 0.5px) rotate(-0.5deg);
        }
        80% {
            transform: translate(-0.5px, -0.5px) rotate(0.5deg);
        }
        90% {
            transform: translate(0.5px, 1px) rotate(0deg);
        }
        100% {
            transform: translate(0.5px, 0px) rotate(-0.5deg);
        }
    }


    #sender {
        padding: 1em;
        width: 200px;
        position: absolute;
        top: 0;
        left: 0;
        display: none;
        flex-direction: column;
    }

    #author-image {
        animation: shake 4s;
        animation-iteration-count: infinite;

        border-radius: 50%;
        border: #23a55a 5px solid;
    }

    #author-name {
        text-align: center;
        color: white;
        font-size: 2.5em;
        font-family: Impact, Haettenschweiler, 'Arial Narrow Bold', sans-serif;
        text-shadow: -1px 0 black, 0 1px black, 1px 0 black, 0 -1px black;
    }

    #containerStream {
        position: relative;
        width: 1920px;
        height: 1080px;
    }

    #movable,
    .movable {
        position: absolute;
        /* text wrap */
        width: 100%;
    }

    #fileStream {
        position: absolute;
    }
</style>

<script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"
        integrity="sha512-q/dWJ3kcmjBLU4Qc47E4A9kTB4m3wuTY7vkFJDTZKjTs8jhyGQnaUrxa0Ytd0ssMZhbNua9hE+E7Qv1j+DyZwA=="
        crossOrigin="anonymous"></script>
<script src="https://code.jquery.com/jquery-3.6.0.js"></script>

<script type="text/javascript" charSet="utf-8">
    let obsWebSocket;
    let FilterEnabled;
    let sourceName = "mediachat";

    loadObsWebSocket();


    function loadObsWebSocket() {

        obsWebSocket = new WebSocket('ws://localhost:4455');

        obsWebSocket.addEventListener('open', () => {
            console.log('Connected to OBS WebSocket');
        });

        obsWebSocket.addEventListener('message', (event) => {
            const response = JSON.parse(event.data);
            console.log('Received response:', response['d']);

            switch (response['d']['requestId']) {
                case '1': // GetSourceFilterList
                    switch (response['d']['requestStatus']['code']) {
                        case 100:
                            //Filter found
                            console.log("Filter found");
                            FilterEnabled = response['d']['responseData']['filterEnabled'];
                            break;
                        case 600:
                            //Filter not found
                            console.log("Filter not found");
                            ObsCreateFilter();
                            break;
                        default:
                            break;
                    }
                    break;
                case '2': // CreateSourceFilter
                    console.log("Filter created");
                    ObsEnableSourceFilter(false);
                    break;
                case '3': // EnableSourceFilter
                    console.log("Hello world !");
                    break;
                default:
                    //console.log(response)
                    break;
            }
        });

        obsWebSocket.addEventListener('close', () => {
            console.log('Connection to OBS WebSocket closed');
            addFilterButton.setAttribute('disabled', true);
        });

        setTimeout(() => {
            const getIdentity = {
                "op": 1,
                "d": {
                    "rpcVersion": 1,
                    "eventSubscriptions": 33
                }
            };

            obsWebSocket.send(JSON.stringify(getIdentity));

            ObsGetSourceFilterList();
        }, 1000);


    }

    function ObsGetSourceFilterList() {

        const GetSourceFilterList = {
            "op": 6,
            "d": {
                "requestType": "GetSourceFilter",
                "requestId": "1",
                "requestData": {
                    "sourceName": sourceName,
                    "filterName": "greenscreen"
                }
            }
        };

        obsWebSocket.send(JSON.stringify(GetSourceFilterList));
    }

    function ObsCreateFilter() {

        const createSourceFilter = {
            "op": 6,
            "d": {
                "requestType": "CreateSourceFilter",
                "requestId": "2",
                "requestData": {
                    "sourceName": sourceName,
                    "filterName": "greenscreen",
                    "filterKind": "chroma_key_filter_v2",
                    "filterSettings": {
                        "key_color_type": "custom",
                        "key_color": 0x00FF00, //green
                    }
                }
            }
        };

        obsWebSocket.send(JSON.stringify(createSourceFilter));
    }


    function ObsEnableSourceFilter(param) {

        const enableSourceFilter = {
            "op": 6,
            "d": {
                "requestType": "SetSourceFilterEnabled",
                "requestId": "3",
                "requestData": {
                    "sourceName": sourceName,
                    "filterName": "greenscreen",
                    "filterEnabled": param
                }
            }
        };

        obsWebSocket.send(JSON.stringify(enableSourceFilter));
    }

    function ObsChangeFilterColor(hexColor) {

        //Code temporaire le temps que je trouve un fix

        switch (hexColor) {
            case "true":
            case "green":
                hexColor = 0x00FF00;
                break;
            case "blue":
                hexColor = 0xFF9900;
                break;
            case "magenta":
                hexColor = 0xFF00FF;
                break;
        }

        const changeSourceFilterSettings = {
            "op": 6,
            "d": {
                "requestType": "SetSourceFilterSettings",
                "requestId": "4",
                "requestData": {
                    "sourceName": sourceName,
                    "filterName": "greenscreen",
                    "filterSettings": {
                        "key_color_type": "custom",
                        "key_color": hexColor
                    }
                }
            }
        }

        obsWebSocket.send(JSON.stringify(changeSourceFilterSettings));
    }
</script>

<script type="text/javascript" charSet="utf-8">
    //Get key parameter
    let key = new URLSearchParams(window.location.search).get('key');

    var timeout;

    var socket = io();
    const containerStream = document.getElementById("containerStream");
    var fileStream = document.getElementById("fileStream");
    var movable = document.getElementById("movable");

    socket.on('connect', function () {
        socket.emit('msg', {data: 'StreamConnected'});
        socket.emit('join', key);
    });

    socket.io.on('reconnect', () => {
        socket.emit('msg', {data: 'StreamReconnected'});
        location.reload();
    })

    socket.on('disconnect', function () {
        socket.emit('msg', {data: 'StreamDisconnected'});
        socket.emit('leave', key);
    });

    //Get the blob with socket
    socket.on('sendFile', function (data) {
        if (timeout != undefined || timeout != 0) {
            clearTimeout(timeout);
        }

        if(!data.haveText){
            if (isMovableShowing()) {
                movable.remove();
            }
        }

        if (data.isLink === 'false') {
            var blob = new Blob([new Uint8Array(data.data.split(",").map((e) => {
                return parseInt(e);
            }))], {type: data.typeFile});
            url = URL.createObjectURL(blob);
        } else {
            //Cors fix
            url = "/cors?url=" + data.data;
        }

        if (isFileShowing()) {
            fileStream.remove();
            hideAuthor();

        }

        if (data.typeFile.includes("image")) {
            containerStream.insertAdjacentHTML('afterbegin', '<img id="fileStream" src="" alt="">');

        } else {
            containerStream.insertAdjacentHTML('afterbegin', '<video id="fileStream"></video>');
        }

        fileStream = document.getElementById("fileStream");
        let file = fileStream;
        file.style.display = "none";

        ObsEnableSourceFilter(data.greenscreen === 'true');
        //ObsChangeFilterColor(data.greenscreen);

        switch (data.left) {
            case "left":
                file.style.left = '0%';
                file.style.top = '50%';
                file.style.transform = 'translateX(-0%)';
                break;
            case "center":
                file.style.left = '50%';
                file.style.top = '50%';
                file.style.transform = 'translateX(-50%)';
                break;
            case "right":
                file.style.left = '100%';
                file.style.top = '50%';
                file.style.transform = 'translateX(-100%)';
                break;
            default:
                // Use the original positioning based on data.left and data.top
                file.style.left = (data.left * data.ratio) + 'px';
                file.style.top = (data.top * data.ratio) + 'px';
                break;
        }

        switch (data.top) {
            case "top":
                file.style.top = '0%';
                file.style.transform += 'translateY(-0%)';
                break;
            case "center":
                file.style.top = '50%';
                file.style.transform += 'translateY(-50%)';
                break;
            case "bottom":
                file.style.top = '100%';
                file.style.transform += 'translateY(-100%)';
                break;
            default:
                // Use the original positioning based on data.left and data.top
                file.style.left = (data.left * data.ratio) + 'px';
                file.style.top = (data.top * data.ratio) + 'px';
                break;
        }

        file.src = url;

        file.style.height = (data.height * data.ratio) + 'px';
        if (data.width === 'auto') {
            file.style.width = 'auto';
        } else {
            file.style.width = (data.width * data.ratio) + 'px';
        }

        try {
            //Parse data.muted to bolean
            data.muted = (data.muted === 'true');
            file.muted = data.muted;
            console.log(data.muted);
            file.currentTime = data.timestamp;

        } catch (e) {
            console.log("Not a video");

        }

        file.addEventListener('ended', function () {
            file.remove();
            hideAuthor();

            if (isMovableShowing()) {
                movable.remove();
            }
        });

        file.addEventListener('canplay', function () {
            $(file).css("display", "inline");

            var audioCtx = new AudioContext();
            var analyser = audioCtx.createAnalyser();
            var distortion = audioCtx.createWaveShaper();

            var source = audioCtx.createMediaElementSource(file);
            audioCtx.resume();
            source.connect(analyser);
            analyser.connect(distortion);
            distortion.connect(audioCtx.destination);

            analyser.fftSize = 256;
            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);


            // Récupérer l'élément à modifier (l'image)
            var authorImage = document.getElementById("author-image");

            function changeBorder() {
                analyser.getByteFrequencyData(dataArray);

                // Calculer une valeur moyenne des données de fréquence
                const averageFrequencyValue = dataArray.reduce((acc, val) => acc + val, 0) / bufferLength;

                // Convertir la valeur de fréquence en une valeur de taille de bordure
                const borderSizeValue = (averageFrequencyValue / 256) * 50;

                // Appliquer la taille de bordure à l'élément
                authorImage.style.borderWidth = borderSizeValue + 'px';

                // Appeler la fonction à chaque nouvelle frame d'animation
                requestAnimationFrame(changeBorder);
            }

            // Appel initial de la fonction
            file.play();
            setAuthor(data)
            changeBorder();

            if (isMovableShowing()) {
                movable.style.display = "inline";
            }
        });

        if (data.typeFile.includes("image")) {
            //Charger l'image 10 secondes
            file.addEventListener('load', function () {
                file.style.display = "inline";
                setAuthor(data)

                if (isMovableShowing()) {
                    movable.style.display = "inline";
                }
            });
            timeout = setTimeout(function () {
                $(file).remove();
                hideAuthor();

                if (isMovableShowing()) {
                    movable.remove();
                }
            }, 10000);
        }

    });

    socket.on('text', function (data) {
        if (isFileShowing()) {
            fileStream.remove();
        }

        if (isMovableShowing()) {
            movable.remove();
        }

        containerStream.insertAdjacentHTML('beforeend', `<span id="movable">${data.data}</span>`);
        movable = document.getElementById("movable");
        movable.style.wordWrap = "break-word";
        movable.style.textAlign = "center";

        //pas propre mais ça marche

        switch (data.left) {
            case "left":
                movable.style.left = "0%";
                movable.style.transform = "translateX(-0%)";
                break;
            case "center":
                movable.style.left = "50%";
                movable.style.transform = "translateX(-50%)";
                break;
            case "right":
                movable.style.left = "100%";
                movable.style.transform = "translateX(-100%)";
                break;
            default:
                // Use the original positioning based on data.left and data.top
                movable.style.left = (data.left * data.ratio) + 'px';
                movable.style.top = (data.top * data.ratio) + 'px';
                movable.style.wordWrap = "normal";
                movable.style.textAlign = "left";
                break;
        }

        switch (data.top) {
            case "top":
                movable.style.maxWidth = "90%";
                movable.style.top = '5%';
                movable.style.transform += 'translateY(-5%)';
                break;
            case "center":
                movable.style.maxWidth = "90%";
                movable.style.top = '50%';
                movable.style.transform += 'translateY(-50%)';
                break;
            case "bottom":
                movable.style.maxWidth = "90%";
                movable.style.top = '95%';
                movable.style.transform += 'translateY(-95%)';
                break;
            default:
                // Use the original positioning based on data.left and data.top
                movable.style.left = (data.left * data.ratio) + 'px';
                movable.style.top = (data.top * data.ratio) + 'px';
                movable.style.wordWrap = "normal";
                movable.style.textAlign = "left";
                break;
        }

        movable.style.fontSize = (data.font_size * data.ratio) + "pt";
        movable.style.color = data.font_color;
        movable.style.fontFamily = data.font_family;

        movable.style.fontWeight = "bold";
        movable.style.webkitTextStrokeWidth = "3px";
        movable.style.webkitTextStrokeColor = "black";

        if (typeof data.haveFile === "boolean") {
            if (data.haveFile) {
                movable.style.display = "none";
            }
        } else {
            if (data.haveFile === "true") {
                movable.style.display = "none";
            }
        }

    });

    socket.on('flush', function () {
        hideAuthor();

        if (isMovableShowing()) {
            movable.remove();
        }

        if (isFileShowing()) {
            fileStream.remove();
        }
    });


    function isFileShowing() {
        return fileStream != null;
    }

    function isMovableShowing() {
        return movable != undefined && movable != null;
    }

    function setAuthor(data) {
        if (!data.anonymous) {

            if (data.width !== 'auto' && (data.width < 1920 && data.height < 1080) && !data.typeFile.includes("audio")) {
                var rect = fileStream.getBoundingClientRect();
                var x = rect.left - 100;
                var y = rect.top - 100;

                document.getElementById("sender").style.left = x + "px";
                document.getElementById("sender").style.top = y + "px";
            } else {
                //If sender exceed the screen
                document.getElementById("sender").style.left = "0px";
                document.getElementById("sender").style.top = "0px";
            }

            document.getElementById("author-name").innerHTML = data.authorName;
            document.getElementById("author-image").src = data.authorAvatar;
            document.getElementById("sender").style.display = "flex";
        }
    }

    function hideAuthor() {
        document.getElementById("sender").style.display = "none";
    }
</script>