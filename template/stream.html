<div id="containerStream"></div>


<div id="sender">
    <img id="author-image" src="">
    <span id="author-name"></span>
</div>

<style>

    @keyframes shake {
        0% {
            transform: translate(0.5px, 0.5px) rotate(0deg) scale(1.01);
        }
        10% {
            transform: translate(-0.5px, -1px) rotate(-0.5deg) scale(1.02);
        }
        20% {
            transform: translate(-1.5px, 0px) rotate(0.5deg) scale(1.03);
        }
        30% {
            transform: translate(1.5px, 1px) rotate(0deg) scale(1.02);
        }
        40% {
            transform: translate(0.5px, -0.5px) rotate(0.5deg) scale(1.01);
        }
        50% {
            transform: translate(-0.5px, 1px) rotate(-0.5deg) scale(1);
        }
        60% {
            transform: translate(-1.5px, 0.5px) rotate(0deg);
        }
        70% {
            transform: translate(1.5px, 0.5px) rotate(-0.5deg);
        }
        80% {
            transform: translate(-0.5px, -0.5px) rotate(0.5deg);
        }
        90% {
            transform: translate(0.5px, 1px) rotate(0deg);
        }
        100% {
            transform: translate(0.5px, 0px) rotate(-0.5deg);
        }
    }


    #sender {
        padding: 1em;
        width: 200px;
        position: absolute;
        top: 0;
        left: 0;
        display: none;
        flex-direction: column;
    }

    #author-image {
        animation: shake 4s;
        animation-iteration-count: infinite;

        border-radius: 50%;
        border: #0e9f6e 5px solid;
    }

    #author-name {
        text-align: center;
        color: white;
        font-size: 2.5em;
        font-family: Impact, Haettenschweiler, 'Arial Narrow Bold', sans-serif;
        text-shadow: -1px 0 black, 0 1px black, 1px 0 black, 0 -1px black;
    }

    #containerStream {
        position: relative;
        width: 1920px;
        height: 1080px;
    }

    #movable,
    .movable {
        position: absolute;
        /* text wrap */
    }

    #fileStream {
        position: absolute;
    }
</style>

<script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"
        integrity="sha512-q/dWJ3kcmjBLU4Qc47E4A9kTB4m3wuTY7vkFJDTZKjTs8jhyGQnaUrxa0Ytd0ssMZhbNua9hE+E7Qv1j+DyZwA=="
        crossOrigin="anonymous"></script>
<script src="https://code.jquery.com/jquery-3.6.0.js"></script>

<script type="text/javascript" charSet="utf-8">
    var timeout;

    var socket = io();
    const containerStream = document.getElementById("containerStream");
    var fileStream = document.getElementById("fileStream");
    var movable = document.getElementById("movable");

    socket.on('connect', function () {
        socket.emit('msg', {data: 'StreamConnected'});

    });

    socket.io.on('reconnect', () => {
        socket.emit('msg', {data: 'StreamReconnected'});
        location.reload();
    })

    socket.on('disconnect', function () {
        socket.emit('msg', {data: 'StreamDisconnected'});
    });

    //Get the blob with socket
    socket.on('sendFile', function (data) {
        if (timeout != undefined || timeout != 0) {
            clearTimeout(timeout);
        }

        if (data.isLink == 'false') {
            var blob = new Blob([new Uint8Array(data.data.split(",").map((e) => {
                return parseInt(e);
            }))], {type: data.typeFile});
            url = URL.createObjectURL(blob);
        } else {
            //Cors fix
            url = "/cors?url=" + data.data;
        }

        if (isFileShowing()) {
            fileStream.remove();
            hideAuthor();

        }

        if (data.typeFile.includes("image")) {
            containerStream.insertAdjacentHTML('afterbegin', '<img id="fileStream" src="" alt="">');

        } else {
            containerStream.insertAdjacentHTML('afterbegin', '<video id="fileStream"></video>');
        }

        fileStream = document.getElementById("fileStream");
        let file = fileStream;
        file.style.display = "none";


        switch (data.left) {
            case "left":
                file.style.left = '0%';
                file.style.top = '50%';
                file.style.transform = 'translateX(-0%)';
                break;
            case "center":
                file.style.left = '50%';
                file.style.top = '50%';
                file.style.transform = 'translateX(-50%)';
                break;
            case "right":
                file.style.left = '100%';
                file.style.top = '50%';
                file.style.transform = 'translateX(-100%)';
                break;
            default:
                // Use the original positioning based on data.left and data.top
                file.style.left = (data.left * data.ratio) + 'px';
                file.style.top = (data.top * data.ratio) + 'px';
                break;
        }

        switch (data.top) {
            case "top":
                file.style.top = '0%';
                file.style.transform += 'translateY(-0%)';
                break;
            case "center":
                file.style.top = '50%';
                file.style.transform += 'translateY(-50%)';
                break;
            case "bottom":
                file.style.top = '100%';
                file.style.transform += 'translateY(-100%)';
                break;
            default:
                // Use the original positioning based on data.left and data.top
                file.style.left = (data.left * data.ratio) + 'px';
                file.style.top = (data.top * data.ratio) + 'px';
                break;
        }

        file.src = url;

        file.style.height = (data.height * data.ratio) + 'px';
        if (data.width === 'auto') {
            file.style.width = 'auto';
        } else {
            file.style.width = (data.width * data.ratio) + 'px';
        }

        try {
            file.muted = data.muted === "true" ? true : false;
            file.currentTime = data.timestamp;

        } catch (e) {
            console.log("Not a video");

        }

        file.addEventListener('ended', function () {
            file.remove();
            hideAuthor();

            if (isMovableShowing()) {
                movable.remove();
            }
        });

        file.addEventListener('canplay', function () {
            $(file).css("display", "inline");

            var audioCtx = new AudioContext();
            var analyser = audioCtx.createAnalyser();
            var distortion = audioCtx.createWaveShaper();

            var source = audioCtx.createMediaElementSource(file);
            audioCtx.resume();
            source.connect(analyser);
            analyser.connect(distortion);
            distortion.connect(audioCtx.destination);

            analyser.fftSize = 256;
            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);


            // Récupérer l'élément à modifier (l'image)
            var authorImage = document.getElementById("author-image");

            function changeBorder() {
                analyser.getByteFrequencyData(dataArray);

                // Calculer une valeur moyenne des données de fréquence
                const averageFrequencyValue = dataArray.reduce((acc, val) => acc + val, 0) / bufferLength;

                // Convertir la valeur de fréquence en une valeur de taille de bordure
                const borderSizeValue = (averageFrequencyValue / 256) * 150;

                // Appliquer la taille de bordure à l'élément
                authorImage.style.borderWidth = borderSizeValue + 'px';

                // Appeler la fonction à chaque nouvelle frame d'animation
                requestAnimationFrame(changeBorder);
            }

            // Appel initial de la fonction
            file.play();
            setAuthor(data)
            changeBorder();

            if (isMovableShowing()) {
                movable.style.display = "inline";
            }
        });

        if (data.typeFile.includes("image")) {
            //Charger l'image 10 secondes
            file.addEventListener('load', function () {
                file.style.display = "inline";
                setAuthor(data)

                if (isMovableShowing()) {
                    movable.style.display = "inline";
                }
            });
            timeout = setTimeout(function () {
                $(file).remove();
                hideAuthor();

                if (isMovableShowing()) {
                    movable.remove();
                }
            }, 10000);
        }

    });

    socket.on('text', function (data) {
        if (isFileShowing()) {
            fileStream.remove();
        }

        if (isMovableShowing()) {
            movable.remove();
        }

        containerStream.insertAdjacentHTML('beforeend', `<span id="movable">${data.data}</span>`);
        movable = document.getElementById("movable");
        movable.style.wordWrap = "break-word";
        movable.style.textAlign = "center";

        //pas propre mais ça marche

        switch (data.left) {
            case "left":
                movable.style.left = "0%";
                movable.style.transform = "translateX(-0%)";
                break;
            case "center":
                movable.style.left = "50%";
                movable.style.transform = "translateX(-50%)";
                break;
            case "right":
                movable.style.left = "100%";
                movable.style.transform = "translateX(-100%)";
            default:
                // Use the original positioning based on data.left and data.top
                movable.style.left = (data.left * data.ratio) + 'px';
                movable.style.top = (data.top * data.ratio) + 'px';
                movable.style.wordWrap = "normal";
                movable.style.textAlign = "left";
                break;
        }

        switch (data.top) {
            case "top":
                movable.style.maxWidth = "90%";
                movable.style.top = '10%';
                movable.style.transform += 'translateY(-10%)';
                break;
            case "center":
                movable.style.maxWidth = "90%";
                movable.style.top = '50%';
                movable.style.transform += 'translateY(-50%)';
                break;
            case "bottom":
                movable.style.maxWidth = "90%";
                movable.style.top = '90%';
                movable.style.transform += 'translateY(-90%)';
                break;
            default:
                // Use the original positioning based on data.left and data.top
                movable.style.left = (data.left * data.ratio) + 'px';
                movable.style.top = (data.top * data.ratio) + 'px';
                movable.style.wordWrap = "normal";
                movable.style.textAlign = "left";
                break;
        }

        movable.style.fontSize = (data.font_size * data.ratio) + "pt";
        movable.style.color = data.font_color;
        movable.style.fontFamily = data.font_family;

        movable.style.fontWeight = "bold";
        movable.style.webkitTextStrokeWidth = "3px";
        movable.style.webkitTextStrokeColor = "black";

        if (typeof data.haveFile === "boolean") {
            if (data.haveFile) {
                movable.style.display = "none";
            }
        } else {
            if (data.haveFile === "true") {
                movable.style.display = "none";
            }
        }

    });

    socket.on('flush', function () {
        hideAuthor();

        if (isMovableShowing()) {
            movable.remove();
        }

        if (isFileShowing()) {
            fileStream.remove();
        }
    });


    function isFileShowing() {
        return fileStream != null;
    }

    function isMovableShowing() {
        return movable != undefined && movable != null;
    }

    function setAuthor(data) {
        if (data.anonymous == "false") {

            if (data.width != 'auto' && (data.width < 1920 && data.height < 1080) && !data.typeFile.includes("audio")) {
                var rect = fileStream.getBoundingClientRect();
                var x = rect.left - 100;
                var y = rect.top - 100;

                document.getElementById("sender").style.left = x + "px";
                document.getElementById("sender").style.top = y + "px";
            } else {
                //If sender exceed the screen
                document.getElementById("sender").style.left = "0px";
                document.getElementById("sender").style.top = "0px";
            }

            document.getElementById("author-name").innerHTML = data.authorName;
            document.getElementById("author-image").src = data.authorAvatar;
            document.getElementById("sender").style.display = "flex";
        }
    }

    function hideAuthor() {
        document.getElementById("sender").style.display = "none";
    }
</script>